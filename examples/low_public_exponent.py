from cryptolib.encoding import bytes2long, long2bytes
from cryptolib.number import lcm, inverse_mod
from cryptolib.rsa_attack import low_public_exponent_attack

p = 101967901158617391733043050137441589975016290388870031967121417143334664382829979958042076082298015951920294538146158699790741332553245126820482380051050456772702337551733489045621782803034992279161835274025876810196945307189440477215559021766817425828566238100635794760666872712650817305218420151281106635753 
q = 48256787695687012245174928425888384125058651908884820054978314428587181016962127006811310041241296935517983691981993922095750404597870258044665970474578373722927860420090223291726183139000058734856188137240854672569952275502253297481396070937162000941087993814195308294085630188319732146112474746975747787369

n = p * q

e = 3
L = lcm(p - 1, q - 1)
d = inverse_mod(e, L)

m = bytes2long(b'crypto{weak_rsa_hahaha}')
c = pow(m, e, n)

print(f"n = {n}")
print(f"e = {e}")
print(f"c = {c}")

m_guess, rslt = low_public_exponent_attack(c, e)

if rslt:
    print("-" * 30)
    print(long2bytes(m_guess))
else:
    print('Failed!')
